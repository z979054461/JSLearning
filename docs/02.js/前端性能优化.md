---
title: 前端性能优化
date: 2021-02-25
lang: "zh-CN"
sidebar: "auto"
categories:
  - JS
tags:
location: HangZhou
---

# Heading

参考链接：https://segmentfault.com/a/1190000022205291
[[toc]]

## 打包方式

```js
//由以下整体打包
() => import(/* webpackMode: "lazy-once" */"@/views/page" + url)
//改为多入口分块打包
() => import(/* webpackChunkName: "chunkName1" */`@/views/page1`
() => import(/* webpackChunkName: "chunkName1" */`@/views/page2`
```

提升第一个菜单页的加载速度。

## 点击时加载

1. 数据请求提前。对于 vue，一些必要数据的后端请求由`mounted`提前到`created`
2. 弹框、下拉框等不可见组件可以通过`v-if`开关调整为第一次点击时加载，提升首屏速度，如：

```vue
<template>
  <div v-if="renderOnDoc">
    <!-- component -->
  </div>
</template>
<script>
export default {
  name: "PreviewPDF",
  model: {
    prop: "showPDF",
    event: "on-close",
  },
  props: {
    showPDF: {
      type: Boolean,
      default: false,
    },
  },
  data() {
    return {
      renderOnDoc: false,
      show: false,
    };
  },
  watch: {
    showPDF(value) {
      if (!!value) {
        this.renderOnDoc = true;
      }
      this.show = value;
    },
  },
};
</script>
```

## 打包压缩

1. `npm install --save-dev compression-webpack-plugin`
2. webpack 配置开启`productionGzip`
3. nginx 打开 gzip 压缩开关
   1. gzip on;
   2. gzip_types text/plain application/x-javascript text/css application/xml application/javascript application/json text/xml 'application/json;charset=utf-8';
4. webpack 配置关闭生产环境的 SourceMap`productionSourceMap`

## 使用服务端渲染

- 客户端渲染: 获取 HTML 文件，根据需要下载 JavaScript 文件，运行文件，生成 DOM，再渲染。

- 服务端渲染：服务端返回 HTML 文件，客户端只需解析 HTML。
  - 优点：首屏渲染快，SEO 好；更快的内容到达时间 (time-to-content)。
  - 缺点：配置麻烦，增加了服务器的计算压力。

## 减少 HTTP 请求

一个完整的 HTTP 请求需要经历 DNS 查找，TCP 握手，浏览器发出 HTTP 请求，服务器接收请求，服务器处理请求并发回响应，浏览器接收响应等过程。
对于 HTTP1.1，可并发使用的 TCP 通道有限（chrome 为 6 个）， 建议**将多个小文件合并为一个大文件**，从而减少 HTTP 请求次数。

## 使用 HTTP2

HTTP2 相比 HTTP1.1 有如下几个优点：

1. 解析速度快

服务器解析 HTTP1.1 的请求时，必须不断地读入字节，直到遇到分隔符 CRLF 为止。而解析 HTTP2 的请求就不用这么麻烦，因为 HTTP2 是基于帧的协议，每个帧都有表示帧长度的字段。

2. 多路复用

HTTP1.1 如果要同时发起多个请求，就得建立多个 TCP 连接，因为一个 TCP 连接同时只能处理一个 HTTP1.1 的请求。

在 HTTP2 上，多个请求可以共用一个 TCP 连接，这称为多路复用。同一个请求和响应用一个流来表示，并有唯一的流 ID 来标识。
多个请求和响应在 TCP 连接中可以乱序发送，到达目的地后再通过流 ID 重新组建。

3. 首部压缩

HTTP2 提供了首部压缩功能。
HTTP2 在客户端和服务器端使用`首部表`来跟踪和存储之前发送的键－值对，对于相同的数据，不再通过每次请求和响应发送。

4. 优先级

HTTP2 可以对比较紧急的请求设置一个较高的优先级，服务器在收到这样的请求后，可以优先处理。

5. 流量控制

由于一个 TCP 连接流量带宽（根据客户端到服务器的网络带宽而定）是固定的，当有多个请求并发时，一个请求占的流量多，另一个请求占的流量就会少。流量控制可以对不同的流的流量进行精确控制。

6. 服务器推送

HTTP2 新增的一个强大的新功能，就是服务器可以对一个客户端请求发送多个响应。换句话说，除了对最初请求的响应外，服务器还可以额外向客户端推送资源，而无需客户端明确地请求。

例如当浏览器请求一个网站时，除了返回 HTML 页面外，服务器还可以根据 HTML 页面中的资源的 URL，来提前推送资源。

## 静态资源使用 CDN

如果服务器是部署在客户内网的，就不存在这个问题。  
内容分发网络（CDN）是一组分布在多个不同地理位置的 Web 服务器。我们都知道，当服务器离用户越远时，延迟越高。CDN 就是为了解决这一问题，在多个位置部署服务器，让用户离服务器更近，从而缩短请求时间。

## 将 CSS 放在文件头部，JavaScript 文件放在底部

所有放在 head 标签里的 CSS 和 JS 文件都会堵塞渲染。如果这些 CSS 和 JS 需要加载和解析很久的话，那么页面就空白了。所以 JS 文件要放在底部，等 HTML 解析完了再加载 JS 文件。

那为什么 CSS 文件还要放在头部呢？  
因为先加载 HTML 再加载 CSS，会让用户第一时间看到的页面是没有样式的、“丑陋”的，为了避免这种情况发生，就要将 CSS 文件放在头部了。  
另外，JS 文件也不是不可以放在头部，只要给 script 标签加上 defer 属性就可以了，异步下载，延迟执行。

## 使用字体图标 iconfont 代替图片图标

1. 字体图标就是将图标制作成一个字体，使用时就跟字体一样，可以设置属性，例如 font-size、color 等等，非常方便。并且字体图标是 svg 矢量图，不会失真。还有一个优点是生成的文件特别小。
2. 使用 [fontmin-webpack](https://github.com/patrickhulce/fontmin-webpack) 插件对字体文件进行压缩

## 善用缓存，不重复加载相同的资源

1. nginx 对于静态文件设置缓存，添加 Expires 或 max-age（图片类型可以设置更长失效时间）
2. 当文件更新了怎么办？怎么通知浏览器重新请求文件？
   1. @TODO 把资源地址 URL 的修改与文件内容关联起来

## 图片优化

1. 图片延迟加载
   在页面中，先不给图片设置路径，只有当图片出现在浏览器的可视区域时，才去加载真正的图片，这就是延迟加载。对于图片很多的网站来说，一次性加载全部图片，会对用户体验造成很大的影响，所以需要使用图片延迟加载。
2. 响应式图片
   响应式图片的优点是浏览器能够根据屏幕大小自动加载合适的图片。

```html
<picture>
  <source srcset="banner_w1000.jpg" media="(min-width: 801px)" />
  <source srcset="banner_w800.jpg" media="(max-width: 800px)" />
  <img src="banner_w800.jpg" alt="" />
</picture>
```

```css
@media (min-width: 769px) {
  .bg {
    background-image: url(bg1080.jpg);
  }
}
@media (max-width: 768px) {
  .bg {
    background-image: url(bg768.jpg);
  }
}
```

3. 调整图片大小
   可以用两张图片来实行优化。一开始，只加载缩略图，当用户悬停在图片上时，才加载大图进行替换。

4. 降低图片质量
   JPG 格式的图片，100% 的质量和 90% 质量的通常看不出来区别，尤其是用来当背景图的时候。我经常用 PS 切背景图时， 将图片切成 JPG 格式，并且将它压缩到 60% 的质量，基本上看不出来区别。

压缩方法有两种，一是通过 webpack 插件 image-webpack-loader，二是通过在线网站进行压缩。
webpack 插件 image-webpack-loader 的用法：

```js
{
  test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,
  use:[
    {
    loader: 'url-loader',
    options: {
      limit: 10000, /* 图片大小小于1000字节限制时会自动转成 base64 码引用*/
      name: utils.assetsPath('img/[name].[hash:7].[ext]')
      }
    },
    /*对图片进行压缩*/
    {
      loader: 'image-webpack-loader',
      options: {
        bypassOnDebug: true,
      }
    }
  ]
}
```

5. 尽可能利用 CSS3 效果代替图片
   有很多图片使用 CSS 效果（渐变、阴影等）就能画出来，这种情况选择 CSS3 效果更好。因为代码大小通常是图片大小的几分之一甚至几十分之一。

6. 使用 webp 格式的图片
   [WebP 相对于 PNG、JPG 有什么优势？](https://www.zhihu.com/question/27201061)
   > WebP 的优势体现在它具有更优的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量；同时具备了无损和有损的压缩模式、Alpha 透明以及动画的特性，在 JPEG 和 PNG 上的转化效果都相当优秀、稳定和统一。

## 提取第三方库

由于引入的第三方库一般都比较稳定，不会经常改变。所以将它们单独提取出来，作为长期缓存是一个更好的选择。
这里需要使用 webpack4 的 splitChunk 插件 cacheGroups 选项。

```js
optimization: {
      runtimeChunk: {
        name: 'manifest' // 将 webpack 的 runtime 代码拆分为一个单独的 chunk。
    },
    splitChunks: {
        cacheGroups: {
            vendor: {
                name: 'chunk-vendors',
                test: /[\\/]node_modules[\\/]/,
                priority: -10,
                chunks: 'initial'
            },
            common: {
                name: 'chunk-common',
                minChunks: 2,//在分割之前，这个代码块最小应该被引用的次数
                priority: -20,//针对cacheGroups ，表示抽取权重，数字越大表示优先级越高。
                chunks: 'initial',
                reuseExistingChunk: true
            }
        },
    }
},
```

## 减少重绘重排

