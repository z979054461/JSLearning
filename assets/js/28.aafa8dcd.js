(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{634:function(t,a,r){"use strict";r.r(a);var s=r(4),v=Object(s.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"heading"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#heading"}},[t._v("#")]),t._v(" Heading")]),t._v(" "),r("p"),r("div",{staticClass:"table-of-contents"},[r("ul",[r("li",[r("a",{attrs:{href:"#存取-读写-方式"}},[t._v("存取（读写）方式")])]),r("li",[r("a",{attrs:{href:"#逻辑结构与物理结构"}},[t._v("逻辑结构与物理结构")])]),r("li",[r("a",{attrs:{href:"#查找、插入和删除操作"}},[t._v("查找、插入和删除操作")])]),r("li",[r("a",{attrs:{href:"#空间分配"}},[t._v("空间分配")])]),r("li",[r("a",{attrs:{href:"#实际应用中存储结构的选择"}},[t._v("实际应用中存储结构的选择")]),r("ul",[r("li",[r("a",{attrs:{href:"#基于存储的考虑"}},[t._v("基于存储的考虑")])]),r("li",[r("a",{attrs:{href:"#基于运算的考虑"}},[t._v("基于运算的考虑")])]),r("li",[r("a",{attrs:{href:"#基于环境的考虑"}},[t._v("基于环境的考虑")])])])])])]),r("p"),t._v(" "),r("h2",{attrs:{id:"存取-读写-方式"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#存取-读写-方式"}},[t._v("#")]),t._v(" 存取（读写）方式")]),t._v(" "),r("p",[t._v("顺序表可以顺序存取，也可以随机存取，链表只能从表头顺序存取元素。")]),t._v(" "),r("h2",{attrs:{id:"逻辑结构与物理结构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#逻辑结构与物理结构"}},[t._v("#")]),t._v(" 逻辑结构与物理结构")]),t._v(" "),r("p",[t._v("顺序表逻辑上相邻的元素物理位置上也相邻。链表逻辑上相邻的元素，物理存储位置不一定相邻，对应的逻辑关系通过指针链接来表示。")]),t._v(" "),r("h2",{attrs:{id:"查找、插入和删除操作"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#查找、插入和删除操作"}},[t._v("#")]),t._v(" 查找、插入和删除操作")]),t._v(" "),r("p",[t._v("对于按值查找，")]),t._v(" "),r("ul",[r("li",[t._v("顺序表无序时，两者的时间内复杂度均为O(n)；")]),t._v(" "),r("li",[t._v("顺序表有序时，可以采用二分查找，时间复杂度为O(log2n)。\n对于按序号查找，")]),t._v(" "),r("li",[t._v("顺序表支持随机访问，时间复杂度为O(1)，而链表平均时间复杂度为O(n)。")]),t._v(" "),r("li",[t._v("顺序表的插入、删除操作，平均需要移动半个表长的元素。链表的插入、删除操作，只需要修改相关节点的指针域即可。\n由于链表的每个节点都带有指针域，存储密度不够大。")])]),t._v(" "),r("h2",{attrs:{id:"空间分配"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#空间分配"}},[t._v("#")]),t._v(" 空间分配")]),t._v(" "),r("p",[t._v("顺序存储在静态存储分配情形下，一旦存储空间装满就不能扩充，若再加入新元素，则会出现内存溢出，因此需要预先分配足够大的存储空间。预先分配过大，可能会导致顺序表后部大量闲置；预先分配过小，又会造成溢出。动态存储分配虽然存储空间可以扩充，但需要移动大量元素，导致操作效率降低，而且若内存中没有更大块的连续存储空间，则会导致分配失败。"),r("br"),t._v("\n链式存储的节点空间只在需要时申请分配，只要内存有空间就可以分配，操作灵活、高效。")]),t._v(" "),r("h2",{attrs:{id:"实际应用中存储结构的选择"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#实际应用中存储结构的选择"}},[t._v("#")]),t._v(" 实际应用中存储结构的选择")]),t._v(" "),r("h3",{attrs:{id:"基于存储的考虑"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#基于存储的考虑"}},[t._v("#")]),t._v(" 基于存储的考虑")]),t._v(" "),r("p",[t._v("难以估计线性表的长度或存储规模时，不宜采用顺序表；链表不用事先估计存储规模，但链表的存储密度较低，显然链式存储结构的存储密度是小于1的。")]),t._v(" "),r("h3",{attrs:{id:"基于运算的考虑"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#基于运算的考虑"}},[t._v("#")]),t._v(" 基于运算的考虑")]),t._v(" "),r("p",[t._v("在顺序表中按序号访问的时间复杂度为O(1)，而链表中按序号访问的时间复杂度为O(n)，因此若经常做的运算是按序号访问数据元素，则顺序表优于链表。"),r("br"),t._v("\n在顺序表中进行插入、删除操作时，平均移动表中一半的元素，当数据元素的信息量较大且表较长时，这一点不应忽视；在链表中进行插入、删除操作时，虽然也要找插入位置，但操作主要是"),r("em",[t._v("比较操作")]),t._v("，从这个角度考虑则链表优于顺序表。")]),t._v(" "),r("h3",{attrs:{id:"基于环境的考虑"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#基于环境的考虑"}},[t._v("#")]),t._v(" 基于环境的考虑")]),t._v(" "),r("p",[t._v("顺序表容易实现，任何高级语言中都有数组类型；链表的操作时基于指针的，相对来讲，前者实现较为简单，这也是考虑的一个因素。")]),t._v(" "),r("p",[t._v("总之，两种存储结构各有所长，选择哪一种由实际问题的主要因素决定。"),r("strong",[t._v("通常较稳定的线性表选择顺序存储，而频繁进行插入、删除操作的线性表（动态性较强）宜选择链式存储")]),t._v("。")])])}),[],!1,null,null,null);a.default=v.exports}}]);