(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{657:function(t,_,v){"use strict";v.r(_);var r=v(4),a=Object(r.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"heading"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#heading"}},[t._v("#")]),t._v(" Heading")]),t._v(" "),v("p"),v("div",{staticClass:"table-of-contents"},[v("ul",[v("li",[v("a",{attrs:{href:"#定义"}},[t._v("定义")])]),v("li",[v("a",{attrs:{href:"#http-的缺点"}},[t._v("HTTP 的缺点")])]),v("li",[v("a",{attrs:{href:"#改进目标"}},[t._v("改进目标")])]),v("li",[v("a",{attrs:{href:"#https-协议的改进"}},[t._v("HTTPS 协议的改进")]),v("ul",[v("li",[v("a",{attrs:{href:"#双向的身份认证"}},[t._v("双向的身份认证")])]),v("li",[v("a",{attrs:{href:"#数据传输的机密性"}},[t._v("数据传输的机密性")])]),v("li",[v("a",{attrs:{href:"#防止重放攻击"}},[t._v("防止重放攻击")])])])]),v("li",[v("a",{attrs:{href:"#https-与-http-原理区别"}},[t._v("HTTPS 与 HTTP 原理区别")]),v("ul",[v("li",[v("a",{attrs:{href:"#http原理"}},[t._v("HTTP原理")])]),v("li",[v("a",{attrs:{href:"#https-原理"}},[t._v("HTTPS 原理")])])])])])]),v("p"),t._v(" "),v("p",[t._v("参考列表：")]),t._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"https://developer.mozilla.org/zh-CN/docs/Glossary/https",target:"_blank",rel:"noopener noreferrer"}},[t._v("HTTPS"),v("OutboundLink")],1)]),t._v(" "),v("li",[v("a",{attrs:{href:"https://baike.baidu.com/item/HTTPS/285356?fr=aladdin",target:"_blank",rel:"noopener noreferrer"}},[t._v("HTTPS-百度百科"),v("OutboundLink")],1)])]),t._v(" "),v("h2",{attrs:{id:"定义"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#定义"}},[t._v("#")]),t._v(" 定义")]),t._v(" "),v("p",[t._v("**HTTPS （安全的 HTTP）**是 HTTP 协议的加密版本。它通常使用 "),v("code",[t._v("SSL")]),t._v(" 或者 "),v("code",[t._v("TLS")]),t._v(" 来加密客户端和服务器之间所有的通信 。这安全的链接允许客户端与服务器安全地交换敏感的数据，例如网上银行或者在线商城等涉及金钱的操作。")]),t._v(" "),v("p",[t._v("HTTPS （全称：Hyper Text Transfer Protocol over SecureSocket Layer），是以安全为目标的 HTTP 通道，在 HTTP 的基础上通过传输加密和身份认证保证了传输过程的安全性。HTTPS 在 HTTP 的基础下加入 SSL，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。 HTTPS 存在不同于 HTTP 的默认端口及一个加密/身份验证层（在 HTTP 与 TCP 之间）。这个系统提供了身份验证与加密通讯方法。它被广泛用于万维网上安全敏感的通讯，例如交易支付等方面。")]),t._v(" "),v("h2",{attrs:{id:"http-的缺点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http-的缺点"}},[t._v("#")]),t._v(" HTTP 的缺点")]),t._v(" "),v("p",[t._v("HTTP 虽然使用极为广泛, 但是却存在不小的安全缺陷, 主要是其数据的"),v("strong",[t._v("明文传送")]),t._v("和"),v("strong",[t._v("消息完整性检测")]),t._v("的缺乏, 而这两点恰好是网络支付, 网络交易等新兴应用中安全方面最需要关注的 。")]),t._v(" "),v("h2",{attrs:{id:"改进目标"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#改进目标"}},[t._v("#")]),t._v(" 改进目标")]),t._v(" "),v("p",[t._v("HTTPS 协议是由 HTTP 加上 "),v("code",[t._v("TLS/SSL")]),t._v(" 协议构建的可进行"),v("code",[t._v("加密传输")]),t._v("、"),v("code",[t._v("身份认证")]),t._v("的网络协议，主要通过"),v("strong",[t._v("数字证书")]),t._v("、"),v("strong",[t._v("加密算法")]),t._v("、"),v("strong",[t._v("非对称密钥")]),t._v("等技术完成互联网数据传输加密，实现互联网传输安全保护。设计目标主要有三个。")]),t._v(" "),v("ol",[v("li",[t._v("数据保密性：保证数据内容在传输的过程中不会被第三方查看。就像快递员传递包裹一样，都进行了封装，别人无法获知里面装了什么。")]),t._v(" "),v("li",[t._v("数据完整性：及时发现被第三方篡改的传输内容。就像快递员虽然不知道包裹里装了什么东西，但他有可能中途掉包，数据完整性就是指如果被掉包，我们能轻松发现并拒收。")]),t._v(" "),v("li",[t._v("身份校验安全性：保证数据到达用户期望的目的地。就像我们邮寄包裹时，虽然是一个封装好的未掉包的包裹，但必须确定这个包裹不会送错地方，通过身份校验来确保送对了地方。")])]),t._v(" "),v("h2",{attrs:{id:"https-协议的改进"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#https-协议的改进"}},[t._v("#")]),t._v(" HTTPS 协议的改进")]),t._v(" "),v("h3",{attrs:{id:"双向的身份认证"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#双向的身份认证"}},[t._v("#")]),t._v(" 双向的身份认证")]),t._v(" "),v("p",[t._v("客户端和服务端在传输数据之前,会通过基于 X.509 证书对双方进行身份认证 。具体过程如下")]),t._v(" "),v("ol",[v("li",[t._v("客户端发起 "),v("em",[t._v("SSL 握手消息")]),t._v("给服务端要求连接。")]),t._v(" "),v("li",[v("em",[t._v("服务端将证书发送给客户端")]),t._v("。")]),t._v(" "),v("li",[v("em",[t._v("客户端检查服务端证书")]),t._v("，确认是否由自己信任的证书签发机构签发。 如果不是，将是否继续通讯的决定权交给用户选择 ( 注意，这里将是一个安全缺陷 )。如果检查无误或者用户选择继续，则客户端认可服务端的身份。")]),t._v(" "),v("li",[v("em",[t._v("服务端要求客户端发送证书")]),t._v("，并检查是否通过验证。失败则关闭连接，认证成功则从客户端证书中获得客户端的公钥，一般为 1024 位或者 2048 位。到此，服务器客户端双方的身份认证结束，双方确保身份都是真实可靠的。")])]),t._v(" "),v("h3",{attrs:{id:"数据传输的机密性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据传输的机密性"}},[t._v("#")]),t._v(" 数据传输的机密性")]),t._v(" "),v("p",[t._v("客户端和服务端在开始传输数据之前，会协商传输过程需要使用的加密算法。 客户端发送协商请求给服务端, 其中包含自己支持的"),v("strong",[t._v("非对称加密的密钥交换算法")]),t._v(" ( 一般是 RSA), "),v("strong",[t._v("数据签名摘要算法")]),t._v(" ( 一般是 SHA 或者 MD5) , "),v("strong",[t._v("加密传输数据的对称加密算法")]),t._v(" ( 一般是 DES),以及"),v("strong",[t._v("加密密钥的长度")]),t._v("。 服务端接收到消息之后，选中安全性最高的算法，并将选中的算法发送给客户端，完成协商。客户端生成随机的字符串，通过协商好的非对称加密算法，使用服务端的公钥对该字符串进行加密，发送给服务端。 服务端接收到之后，使用自己的私钥解密得到该字符串。在随后的数据传输当中，使用这个字符串作为密钥进行对称加密 。")]),t._v(" "),v("h3",{attrs:{id:"防止重放攻击"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#防止重放攻击"}},[t._v("#")]),t._v(" 防止重放攻击")]),t._v(" "),v("p",[t._v("重放攻击，是指攻击者发送一个目的主机已接收过的包，来达到欺骗系统的目的，主要用于身份认证过程，破坏认证的正确性。\nSSL 使用"),v("em",[t._v("序列号")]),t._v("来保护通讯方免受报文重放攻击。这个序列号被加密后作为数据包的负载。在整个 SSL 握手中,都有一个"),v("em",[t._v("唯一的随机数来标记 SSL 握手")]),t._v("。 这样防止了攻击者嗅探整个登录过程，获取到加密的登录数据之后，不对数据进行解密, 而直接重传登录数据包的攻击手法。")]),t._v(" "),v("p",[t._v("总结来说，HTTPS 的改进点在于创造性的使用了非对称加密算法，在不安全的网路上，安全的传输了用来进行对称加密的密钥，"),v("strong",[t._v("综合利用了非对称加密的安全性和对称加密的快速性")]),t._v("。")]),t._v(" "),v("h2",{attrs:{id:"https-与-http-原理区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#https-与-http-原理区别"}},[t._v("#")]),t._v(" HTTPS 与 HTTP 原理区别")]),t._v(" "),v("p",[t._v("HTTPS 主要由两部分组成：HTTP + SSL / TLS，也就是在 HTTP 上又加了一层处理加密信息的模块。服务端和客户端的信息传输都会通过 TLS 进行加密，所以传输的数据都是加密后的数据。")]),t._v(" "),v("h3",{attrs:{id:"http原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#http原理"}},[t._v("#")]),t._v(" HTTP原理")]),t._v(" "),v("ol",[v("li",[t._v("客户端的浏览器首先要通过网络与服务器建立连接，该连接是通过"),v("code",[t._v("TCP")]),t._v(" 来完成的，一般 TCP 连接的端口号是80。 建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是 MIME 信息包括请求修饰符、客户机信息和许可内容")]),t._v(" "),v("li",[t._v("服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能的内容")])]),t._v(" "),v("h3",{attrs:{id:"https-原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#https-原理"}},[t._v("#")]),t._v(" HTTPS 原理")]),t._v(" "),v("ol",[v("li",[t._v("客户端将它所支持的"),v("em",[t._v("算法列表")]),t._v("和一个用作产生密钥的"),v("em",[t._v("随机数")]),t._v("发送给服务器")]),t._v(" "),v("li",[t._v("服务器从算法列表中选择一种加密算法，并将它和一份包含服务器"),v("em",[t._v("公用密钥的证书")]),t._v("发送给客户端；该证书还包含了用于认证目的的"),v("em",[t._v("服务器标识")]),t._v("，服务器同时还提供了一个用作产生密钥的"),v("em",[t._v("随机数")])]),t._v(" "),v("li",[t._v("客户端对服务器的证书进行验证（参考"),v("em",[t._v("数字签名")]),t._v("），并抽取服务器的公用密钥；然后，再产生一个称作 pre_master_secret 的"),v("em",[t._v("随机密码串")]),t._v("，并使用服务器的公用密钥对其进行加密（参考非对称加 / 解密），并将加密后的信息发送给服务器")]),t._v(" "),v("li",[t._v("客户端与服务器端根据 pre_master_secret 以及客户端与服务器的随机数值独立计算出"),v("em",[t._v("加密和 MAC密钥")]),t._v("（参考 DH密钥交换算法）")]),t._v(" "),v("li",[t._v("客户端将所有握手消息的 MAC 值发送给服务器")]),t._v(" "),v("li",[t._v("服务器将所有握手消息的 MAC 值发送给客户端")])])])}),[],!1,null,null,null);_.default=a.exports}}]);