(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{638:function(t,e,a){"use strict";a.r(e);var l=a(4),i=Object(l.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"heading"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#heading"}},[t._v("#")]),t._v(" Heading")]),t._v(" "),a("p"),a("div",{staticClass:"table-of-contents"},[a("ul",[a("li",[a("a",{attrs:{href:"#定义"}},[t._v("定义")])]),a("li",[a("a",{attrs:{href:"#操作"}},[t._v("操作")])])])]),a("p"),t._v(" "),a("h2",{attrs:{id:"定义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#定义"}},[t._v("#")]),t._v(" 定义")]),t._v(" "),a("p",[t._v("线性表的顺序存储又称顺序表，它是用一组"),a("code",[t._v("地址连续的存储单元")]),t._v("依次存储线性表中的数据元素，从而使得逻辑上相邻的两个元素在物理位置上也相邻。\n假设线性表L的起始位置是LOC(A),sizeof(EleType)是元素大小。")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"left"}},[t._v("数组下标")]),t._v(" "),a("th",{staticStyle:{"text-align":"left"}},[t._v("顺序表")]),t._v(" "),a("th",{staticStyle:{"text-align":"right"}},[t._v("内存地址")])])]),t._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("0")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("a1")]),t._v(" "),a("td",{staticStyle:{"text-align":"right"}},[t._v("LOC(A)")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("1")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("a2")]),t._v(" "),a("td",{staticStyle:{"text-align":"right"}},[t._v("LOC(A)+sizeof(EleType)")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("2")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("a3")]),t._v(" "),a("td",{staticStyle:{"text-align":"right"}},[t._v("LOC(A)+2*sizeof(EleType)")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("...")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("...")]),t._v(" "),a("td",{staticStyle:{"text-align":"right"}},[t._v("...")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("i-1")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("ai")]),t._v(" "),a("td",{staticStyle:{"text-align":"right"}},[t._v("LOC(A)+(i-1)*sizeof(EleType)")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("...")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("...")]),t._v(" "),a("td",{staticStyle:{"text-align":"right"}},[t._v("...")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("n-1")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("an")]),t._v(" "),a("td",{staticStyle:{"text-align":"right"}},[t._v("LOC(A)+(n-1)*sizeof(EleType)")])])])]),t._v(" "),a("p",[t._v("一维数组可以静态分配，也可以动态分配。在静态分配时，由于数组的大小和空间已经固定，一旦空间占满，再加入新的数据将会溢出，进而导致程序奔溃。而在动态分配时，数组空间是在程序执行期间通过动态分配语句分配的，一旦空间快要占满就另外开辟一片更大的空间替换，从而达到扩充的目的。"),a("br"),t._v("\n优点：")]),t._v(" "),a("ol",[a("li",[t._v("随机访问，即通过首地址和元素序号可以再O(1)的时间复杂度内找到指定元素。")]),t._v(" "),a("li",[t._v("存储密度高，每个节点只存储元素。\n缺陷："),a("br"),t._v("\n由于逻辑上相邻的元素物理上也相邻，所以插入和删除需要移动大量元素。")])]),t._v(" "),a("h2",{attrs:{id:"操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#操作"}},[t._v("#")]),t._v(" 操作")]),t._v(" "),a("p",[t._v("数组的基本操作，略过。")])])}),[],!1,null,null,null);e.default=i.exports}}]);